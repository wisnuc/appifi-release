'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = asyncToBluebird;

var _babelPluginSyntaxAsyncFunctions = require('babel-plugin-syntax-async-functions');

var _babelPluginSyntaxAsyncFunctions2 = _interopRequireDefault(_babelPluginSyntaxAsyncFunctions);

var _babelTraverse = require('babel-traverse');

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _babelHelperFunctionName = require('babel-helper-function-name');

var _babelHelperFunctionName2 = _interopRequireDefault(_babelHelperFunctionName);

var _babelTemplate = require('babel-template');

var _babelTemplate2 = _interopRequireDefault(_babelTemplate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FUNCTION_TYPES = ['FunctionDeclaration', 'FunctionExpression', 'ArrowFunctionExpression'];

var BUILD_WRAPPER = (0, _babelTemplate2.default)('\n\t(() => {\n\t\tvar REF = FUNCTION;\n\t\treturn function NAME(PARAMS) {\n\t\t\treturn REF.apply(this, arguments);\n\t\t};\n\t})\n');

var NAMED_BUILD_WRAPPER = (0, _babelTemplate2.default)('\n\t(() => {\n\t\tvar REF = FUNCTION;\n\t\tfunction NAME(PARAMS) {\n\t\t\treturn REF.apply(this, arguments);\n\t\t}\n\t\treturn NAME;\n\t})\n');

function asyncToBluebird(pluginArg) {
	var t = pluginArg.types;


	function classOrObjectMethod(path, state, hasAwait) {
		var node = path.node;
		var body = node.body;


		node.async = false;
		node.generator = hasAwait; // selbst hinzugef√ºgt (richtig so?)

		var container = t.functionExpression(null, [], t.blockStatement(body.body), true);
		container.shadow = true;
		var bbImport = state.addImport('bluebird', hasAwait ? 'coroutine' : 'method');
		body.body = [t.returnStatement(t.callExpression(t.callExpression(bbImport, [container]), []))];
	}

	function plainFunction(path, state, hasAwait) {
		var node = path.node;

		var isDeclaration = path.isFunctionDeclaration();
		var asyncFnId = node.id;

		var wrapper = BUILD_WRAPPER;
		if (path.isArrowFunctionExpression()) path.arrowFunctionToShadowed();else if (!isDeclaration && asyncFnId) wrapper = NAMED_BUILD_WRAPPER;

		node.async = false;
		node.generator = hasAwait;

		node.id = null;

		if (isDeclaration) node.type = 'FunctionExpression';

		var bbImport = state.addImport('bluebird', hasAwait ? 'coroutine' : 'method');
		var built = t.callExpression(bbImport, [node]);
		var container = wrapper({
			NAME: asyncFnId,
			REF: path.scope.generateUidIdentifier('ref'),
			FUNCTION: built,
			PARAMS: node.params.map(function () {
				return path.scope.generateUidIdentifier('x');
			})
		}).expression;

		if (isDeclaration) {
			var declar = t.variableDeclaration('let', [t.variableDeclarator(t.identifier(asyncFnId.name), t.callExpression(container, []))]);
			declar._blockHoist = true;

			path.replaceWith(declar);
		} else {
			var retFunction = container.body.body[1].argument;
			if (!asyncFnId) {
				(0, _babelHelperFunctionName2.default)({
					node: retFunction,
					parent: path.parent,
					scope: path.scope
				});
			}

			if (!retFunction || retFunction.id || node.params.length) {
				// we have an inferred function id or params so we need this wrapper
				path.replaceWith(t.callExpression(container, []));
			} else {
				// we can omit this wrapper as the conditions it protects for do not apply
				path.replaceWith(built);
			}
		}
	}

	return {
		inherits: _babelPluginSyntaxAsyncFunctions2.default,
		visitor: {
			Function: function Function(path, state) {
				var node = path.node;
				var scope = path.scope;

				if (!node.async || node.generator) return;
				var hasAwait = _babelTraverse2.default.hasType(node.body, scope, 'AwaitExpression', FUNCTION_TYPES);

				(0, _babelTraverse2.default)(node, {
					blacklist: FUNCTION_TYPES,

					AwaitExpression: function AwaitExpression(path2) {
						// eslint-disable-next-line no-param-reassign
						path2.node.type = 'YieldExpression';
					}
				}, scope);

				var isClassOrObjectMethod = path.isClassMethod() || path.isObjectMethod();
				(isClassOrObjectMethod ? classOrObjectMethod : plainFunction)(path, state, hasAwait);
			}
		}
	};
}

