/*jslint node: true, nomen: true */
"use strict";

var mm = require('musicmetadata');
var Mime = require('mime');
var Util = require('util');

var debug = require('debug')('upnpserver:audio_musicmetadata');

var logger = require('../logger');
var ContentHandler = require('./contentHandler');

function Audio_MusicMetadata() {
}

Util.inherits(Audio_MusicMetadata, ContentHandler);

module.exports = Audio_MusicMetadata;

Audio_MusicMetadata.prototype.prepareNode = function(node, callback) {

  var attributes = node.attributes;

  var path = attributes.contentURL;

  var self = this;

  node.service.getContentProvider(path).createReadStream(
      null,
      path,
      null,
      function(error, stream) {
        if (error) {
          return callback(error);
        }

        var parsing = true;

        try {
          mm(stream, function(error, tags) {
            parsing = false;

            try {
              stream.destroy();
            } catch (x) {
              logger.error("Can not close stream", x);
            }

            if (debug.enabled) {
              debug("Musicmetadata tags of ", path, "=>", tags);
            }

            if (error) {
              logger.error("MM can not parse tags of path=", path, " error=",
                  error);
              return callback();
            }

            if (!tags) {
              logger.error("MM does not support: " + path);
              return callback();
            }

            [ 'title', 'album', 'duration' ].forEach(function(n) {
              if (tags[n]) {
                attributes[n] = tags[n];
              }
            });

            function normalize(strs) {
              var r = [];
              if (!strs || !strs.length) {
                return r;
              }
              strs.forEach(function(str) {
                str.split(',').forEach(
                    function(tok) {
                      tok = tok.replace(/\w\S*/g, function(txt) {
                        return txt.charAt(0).toUpperCase() +
                            txt.substr(1).toLowerCase();
                      });

                      r.push(tok.trim());
                    });
              });
              return r;
            }

            attributes.artists = normalize(tags.artist);
            attributes.genres = normalize(tags.genre);

            if (tags.year) {
              attributes.year = tags.year && parseInt(tags.year, 10);
            }

            var otw = tags.track && typeof (tags.track.no) === "number" &&
                tags.track.no;
            if (otw) {
              attributes.originalTrackNumber = otw;
            }

            if (tags.picture) {
              attributes.albumArts = attributes.albumArts || [];

              var index = 0;
              tags.picture.forEach(function(picture) {
                attributes.albumArts.push({
                  contentHandlerKey : self.key,
                  format : picture.format,
                  key : index++
                });
              });
            }

            return callback();
          });
        } catch (x) {
          if (parsing) {

            try {
              stream.destroy();
            } catch (x) {
              logger.error("Can not close stream", x);
            }

            logger.error("MM: Parsing exception" + attributes.contentURL, x);
            return callback();
          }

          throw x;
        }

      });

};

Audio_MusicMetadata.prototype.processRequest = function(node, request,
    response, path, parameters, callback) {

  var albumArtKey = parseInt(parameters.albumArtKey, 10);
  if (isNaN(albumArtKey) || albumArtKey < 0) {
    return callback("Invalid albumArtKey parameter (" + parameters.albumArtKey +
        ")", true);
  }

  var path = node.attributes.contentURL;
  // console.log("Get stream of " + node, node.attributes);

  this._getPicture(node, path, albumArtKey, function(error, picture) {

    if (!picture.format || !picture.data) {
      return callback('Invalid picture for node #' + node.id + " key=" +
          albumArtKey, true);
    }

    response.setHeader("Content-Type", Mime.lookup(picture.format));
    response.setHeader("Content-Size", picture.data.length);

    response.end(picture.data, function() {
      callback(null, true);
    });
  });
};

Audio_MusicMetadata.prototype._getPicture = function(node, path, pictureIndex,
    callback) {

  node.service.getContentProvider(node).createReadStream(null, path, null,
      function(error, stream) {
        if (error) {
          return callback(error);
        }

        mm(stream, function(error, tags) {
          try {
            stream.destroy();
          } catch (x) {
            logger.error("Can not close stream", x);
          }

          if (error) {
            logger.error("Can not parse ID3 of " + path, error);
            return callback("Can not parse ID3");
          }

          if (!tags || !tags.picture || tags.picture.length <= pictureIndex) {
            return callback('Picture #' + pictureIndex + "' not found");
          }

          var picture = tags.picture[pictureIndex];
          tags = null;

          return callback(null, picture);
        });
      });
};
